AWS Lambda Versions

When you work on a Lambda function we work on $LATEST
When we are happy with our code state we can publish it can create a new version.
now the version you create say V1 is immutable.
then next version V2 will also be immutable

Versions get their own ARN(Amazon Resource Name)
Version = code + configuration(nothing can be changed)
Each version of the lambda can be accessed


Lambda Aliases

Pointers to Lambda function versions
We can defina a dev, test, prod aliases and have them point at different lambda versions
Aliases are mutable

Aliases enable canary deployment by assigning weights to lambda functions.
Aliases enable stable configuration of our event triggers/ destinations.

Aliases have their own ARNs
Aliases can't refer to other aliases.



Go to Lambda > Create function >  Author from scratch > Function Name > Runtime > Create Function


import json

def lambda_handler(event, context):
    return "this is version1"

>Deploy it 

Then >Test
Create new test event
Event template
Event name
>Create

Then >Test

Say we are very happy with this code and we want name it version1
>Action >Publish new version from $LATEST

>Publish

This has created version1  [Now we can't change the code in it]
Test the function

Now say we want to keep on editing our version

Go back to our main function

import json

def lambda_handler(event, context):
    return "this is version2"

>Deploy 
>Test

>Actions > Publish new version from $LATEST
>Publish


Now we need to play with aliases

Under Versions Tab we can see all the versions we created

Now go to alias tab 
>Create Alias 
Name: dev
Version: $LATEST

>Create Alias
Name: Test
Version: 2

>Create Alias
Name: Prod
Version: 1


With aliases we can start doing some weights

Aliases Tab
Select prod >Edit
>weighted alias >Additional version: 2 Weight: 50
>Save

Now >Test

in results it will show version1 and version2 50% of times each


Once you see version2 is working great 
make weight of version2 100%










Lambda Environment Variables:

Environment variable = key/value pair in "String" form
Adjust the function behaviour without updating code
The environment variables are available to your code
Lambda service adds its own system variables as well


Helpful to store secrets(encrypted by KMS)
Secrets can be encrypted by the Lambda Service key, or your own CMK.

Create a function > Author from Scratch


import json
import os

def lambda_handler(event, context):
    return os.getenv("ENVIRONMENT_NAME")


>Deploy to save the changes

Select this lambda function go to configuration tab
on left hand side > Environment variables

Key
ENVIRONMENT_NAME

Value
dev

There is encryption configuration which we can have but we will do this in security section of course
right now this env variable is unencrypted

>Save

>Test 
Event name = sample event
Create

>Test
In response you should get dev


Again go to environment variables change the value of ENVIRONMENT_NAME to prod and save the function

>Test
response will be 










Lambda Concurrency and Throttling:

Concurrency limit: up to 1000 concurrent executions

Can set a "reserved concurrency" at the function level (=limit)
Each invocation over the concurrency limit will trigger a "Throttle"
Throttle behaviour:
  If synchronous invocation => return ThrottleError -429
  If asynchronous invocation => retry automatically and then go to DLQ
If you need a higher limit, open a support ticket

Lambda Concurrency Issue

If you don't reserve(=limit) concurrency, the following can happen:

users ---> ALB ---> Lambda fn ----> assume it goes upto 1000 concurrent executions

Few users ---> API Gateway ---> Lambda fn     THROTTLE!

SDK/CLI ---> Lambda fn     THROTTLE!




Concurrency and Asynchronous Invocations
            ----New file event----> Lambda invoked
S3 bucket   ----New file event----> Lambda invoked
            ----New file event----> Lambda invoked


If the function doesn't have enough concurrency available to process all events, additional requests are throttled.

For throttling errors(429) and system errors(500-series), Lambda returns the event to the queue and attempts to run the function again for upto 6 hours.

The retry interval increases exponentially from 1 second after first attempt to a maximum of 5 minutes.





Cold Starts and Provisioned Concurrency.

Cold Start: 
   New instance => code is loaded and code outside the handler run (init)
   If the init is large (code, dependencies, SDK..) this process can take some time.
   First request served by the new instances has higher latency than the rest

Provisioned Concurrency:
  Concurrency is allocated before the function is invoked(in advance)
  So the cold start never happens and all invocations have low latency
  Application Auto Scaling can manage concurrency (schedule or target utilization)

Note: 
  Note: cold starts in VPC have been dramatically reduced in Oct & Nov 2019



>Concurrency tab
By default it will show Unreserved account concurrency of 1000 

Unreserved account concurrency is now lower
AWS raises quotas automatically based on usage, or you can request a quota increase.

This default value is shared by all the lambda functions in your account.

>Edit

Reserve concurrency = 20
> save

now you will have 20 for this function and 980 left for others.


To test concurrecny set Reserve concurrency = 0
As this will make the lambda function always throttle


Go to >Test tab hit >Test

Calling the invoke API action failed with this message: Rate Exceeded.

Now change the Reserve concurrency to some bigger value than 0 OR change it to unreserved concurrency.

Test again, it will succeed


We can also provisioned concurrency to remove these cold starts.

>Add

Qualifier type: 
Alias or Version

we can't select latest version here. We want a published version.





Lambda - File Systems Mounting

Lambda functions can access EFS file systems if they are running in a VPC

Configure Lambda to mount EFS file systems to local directory during initialization.

Must leverage EFS Access Points

Limitation: watch out for the EFS connection limits (one function instance = one connection) and connection burst limits

storage options for Lambda
                           max                                Persistence   Content    storageType      sharingPerm     relative data access speed from lambda
Ephermal storage /tmp     10gb                                 Ephermal       dynamic    file system        func only       fastest                            any file system operation
Lambda layers              5layers per fn[total=250mb]         Durable        static     archive            IAM             fastest                             immutable
amazon s3                 Elastic                              Durable        dynamic     object            IAM              fast                              atomic with versioning
amazon efs                Elastic                              Durable        dynamic     file sytem        IAM              very fast                          any file system operation
