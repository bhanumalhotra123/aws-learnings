Infrastructure as code

  Cloud Formation
Declarative programming(no need to figure out ordering and orchestration)

 create template 
  It gives you everything in correct order

  Version control using git

Seperation of concern: Create many stacks for many apps and many layers
Ex: 
  VPC stacks
  Network stacks
  App stacks


  Each time we create ElasticBeanstalk, it creates cloudformation template behind the scenes.

Don't re-invent
    Leverage existing templates on web
    Leverage the documentation

Templates have to be uploaded in S3 and then referenced in CloudFormation.
To update a template we can't edit previous ones. We have to re-upload a new version of the template to AWS.

Stacks are identified by a name.
Deleting a stack deletes every single artifact that was created by CloudFormation


Manual way:
    Edit templates in the CloudFormation Designer.
    Using the console to input parameters, etc.
Automated way:
    Edit templates in a YAML file
    Using the AWS CLI to deploy the templates
    Recommended way when you fully want to automate your flow.



CloudFormation Building Blocks.
    Templates components 
    1. Resources: your AWS resources declared in the template(MANDATORY)
    2. Parameters: the dynamic inputs for your template
    3. Mappings: the static variables for your template
    4. Outputs: References to what has been created
    5. Conditionals: List of conditions to perform resource creation
    6. Metadata

    Template helpers:
    1. References
    2. Functions


Introductory Example:
1. Create a EC2 instance
2. Create and add and Elastic IP to it.
3. Add two security groups to it.

  
Go to cloudformation > Set N.Virginia for now.

>Create Stack > With new resources? OR With existing resoures

  > Template is ready OR Use a sample template OR Create template in Designer.

  Choose a file
  Give a stack name

  You get to review
  Create Stack 

  Under the Events tab
  You can see things are getting initiated.

  You can check on specific resource  by going to its console.
  Or you can go to resources tab and have links there.



  ---
  Resources:
    MyInstance:
      Type: AWS::EC2::Instances
      Properties:
        AvailabilityZone: us-east-1a
        ImageId: ami-a4c7edb 
        InstanceType: t2.micro



          Now assume we want to use the following template: Instead of the one mentioned above that we had used for the previous setup.

  ---
    Parameters:
      SecurityGroupDescription:
         Description: Security Group Description
         Type: String

    Resources:
      MyInstance:
      Type: AWS::EC2::Instances
      Properties:
        AvailabilityZone: us-east-1a
        ImageId: ami-a4c7edb 
        InstanceType: t2.micro
        SecurityGroups:
          - !Ref SSHSecurityGroup
          - !Ref ServerSecurityGroup

      MyEIP:
        Type: AWS::EC2::EIP
        Properties:
          InstanceId: !Ref MyInstance

      SSHSecurityGroup:
        Type: AWS::EC2::SecurityGroup
        Properties:
          GroupDescription: Enable SSH access via port 22
          SecurityGroupIngress:
          - CidrIP: 0.0.0.0/0
            FromPort: 22
            IpProtocol: tcp
            ToPort: 22

     ServiceSecurityGroup:
        Type: AWS::EC2::SecurityGroup
        Properties:
          GroupDescription: !Ref SecurityGroupDescription
          SecurityGroupIngress:
          - IpProtocol: tcp
            FromPort: 80    
            ToPort: 80
            CidrIP: 0.0.0.0/0
          - IpProtocol: tcp
            FromPort: 22
            ToPort: 22
            CidrIp: 192.168.1.1/32

Select the stack you created > Update
              Use Current template OR Replace current template OR Edit template in designer

Go for Replace current template > Upload a template         

click on next: Now you will be prompted to give the value of the parameter you had:

SecurityGroupDescription: 
Enter whatever you want and go next

Change Set Review
  It tells you the differences, like eip will be edded , instance will be modified (it shows wether it will be replaced or not) and so on.
 Next

  In events you will see update in  progress.
              
Doesn't matter whatever order you had given



What if you terminate your instance?
Other things such as security groups, elasticIPs still exist.

Instead  select your stack and delete stack so that it deletes everything.

Even the deletion happens in correct sequence
first eip
2nd instance, then 
sg

Every thing has to happen from cloudformation onky.



You can use yaml and cf

YAML Course.
JSON is horrible for CF

Key value pairs
nested objects
supported arrays
multi line string        

address:
  lines: |
      458 walkman Dr.
      suite #292
  city: pingpong



Resources are the core of your CF
224 resouces
Resource to learn them: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html



For EC2:

https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/AWS_EC2.html

EIP:
https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html




Some common questions:

Can I create dynamic amout of resources?

No, you can't. Everything in the CF template has to be declared. You can't perform code genertation there.

Is every AWS Service Supported?
Almost. Only few select few niches are not there yet.
You can work around that  using aws lambda custom resources.




       


What are parameters?

Parameters are a way to provide inputs to your AWS CloudFormation template

They are imp to know about if:
  You want to reuse your templates across the company
  Some inputs can not be determined ahead of time.

Parameters are extremely powerful, controlled and can prevent errors


ASK yourself:
 Is this CloudFormation resource config likely to change in the future?
 If so, make it a paramter.

Parameters can be controlled by all these settings:

Type:
    String
    Number
    CommaDelimitedList
    List<Type>
    AWS Parameter(to help catch invalid values - match against existing values in the AWS Account)
Description
Constraints
ConstraintDescription
Min/MaxLength
Min/Max Value
Defaults
AllowedValues(array)
AllowedPattern(regexp)
NoEcho(Boolean)



How do you Reference a Parameter?
The Fn::Ref function can be leveraged to reference parameters
Parameters can be used anywhere in a template.
The shorthand for this in YAML is !Ref

DSubnet1:
  Type: AWS::EC2::Subnet
  Properties:
    VpcId: !Ref MyVPC


Pseudo Parameters
AWS offers us pseudo parameters in any CloudFormation template
These can be used at any time and are enabled by default.

AWS:AccountId
AWS:NotificationARNs
AWS:NoValue
AWS:Region
AWS:StackId
AWS:StackName




What are mappings?

Mappings are fixed variables within your CloudFormation Template
They're very handy to differentiate b/w diff envs, regions, AMI types etc
Example:

Mappings:
  Mapping01:
    Key01:
      Name: Value01
    Key02:
      Name: Value02
    Key03: 
      Name: Value03

RegionMaps:
  us-east-1:
    "32": "ami-6411e20d"
    "64": "ami-7a11e213"
  us-west-1:
     "32": "ami-c9c7978c"
     "64": "ami-cfc7978a"


Mapping VS Parameters

M: When you know all values in advance
such as Region, AZ, AWS Account, env, etc...

They allow safer control over the template.


Use parameters when the values are really user specific.



Accessing maping values:
We use Fn::FindMap to return a named value from a specific key.

!FindInMap [ MapName, TopLevelKey, SecondLevelKey ]

  

AWSTemplateFormatVersion: "2010-09-09"
Mappings:
  RegionMaps:
  us-east-1:
    "32": "ami-6411e20d"
    "64": "ami-7a11e213"
  us-west-1:
     "32": "ami-c9c7978c"
     "64": "ami-cfc7978a"
Resources:
  myEC2Instance:
    Type: "AWS::EC2::Instance"
    Properties:
    ImageId: !FindInMap [RegionMap, !Ref "AWS::Region", 32]





What are outputs?
The outputs section declares optional outputs values that we can import into other stacks(if you export them first)!

You can also view the outputs in  the AWS Console or in using the AWS CLI
They're very useful for example if you define a network CloudFormation, and output the variables such as VPC ID and your Subnet IDs.

It is the best way to perform collaboration cross stack, as you let expert handle their own part of the stack.


You can't delete a CloudFormation Stack if its outputs are being referenced by another CloudFormation Stack.


Example:

Outputs:
  StackSSHSecurityGroup:
  Description: The SSH Security Group for our Company
  Value: !Ref MyCompanyWideSSHSecurityGroup
  Export: 
    Name: SSHSecurityGroup           #the StackSSHSecurityGroup will be exported with the name SSHSecurityGroup


We then create a second template that leverages that security group.
For this we use the Fn::ImportValue function
You can't delete the underlying stack until all references are delted too.


     Resources:
      MyInstance:
      Type: AWS::EC2::Instances
      Properties:
        AvailabilityZone: us-east-1a
        ImageId: ami-a4c7edb 
        InstanceType: t2.micro
        SecurityGroups:
          - !ImportValue SSHSecurityGroup





What are conditions used for?
Conditions are used to control the creation of resources or outputs based on a condition.

Conditions can be whatever you want them to be, but common ones are:
   1.Environment(dev/test/prod)
   2. AWS Region
   3. AWS parameter value
Each condition can reference another condition, parameter value or mapping.


How to define a condition?

Condtions:
  CreateProdResources: !Equals [ !Ref EnvType, prod ]

Fn::Equal
Fn::And
Fn::If
Fn::Not
Fn::Or


How do we use a condition?

Resources:
  MountPoint:
    Type: "AWS::EC2::VolumeAttachment"
    Condition: CreateProdResources         #Here it checks wether the condition is true or not.



CloudFormation
Must know Intrinsic Functions:

Ref
Fn::GetAtt
Fn::FindInMap
Fn::ImportValue
Fn::Join
Fn::Sub
Condition Functions(Fn::If, Fn::Not, Fn::Equals, etc ...)



Fn::Ref function can be leveraged to reference 
   Parameters  => Returns the value of the parameter
   Resources   => returns the physical ID of the underlying resource(ex: EC2 ID)
The shorthand for this in YAML is !Ref



DbSubnet1:
  Type: AWS::EC2::Subnet
  Properties:
    VpcId: !Ref MyVPC




Fn::GetAtt

Attributes are attachde to any resources you create
To know the attributes of your resources, the best place to look at is the documentation.

https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/Welcome.html


Resources:
  EC2Instance:
    Type: "AWS::EC2::Instance"
    Properties:
      ImageId: ami-1234567
      InstanceType: t2.micro

NewVolume:
  Type: "AWS::EC2::Volume"
  Condition: CreateProdResources
  Properties:
    Size: 100
    AvailabilityZone:
        !GetAtt EC2Instance.AvailabilityZone


Fn::FindInMap
Accessing Mapping Values

AWSTemplateFormatVersion: "2010-09-09"
Mappings:
  RegionMaps:
  us-east-1:
    "32": "ami-6411e20d"
    "64": "ami-7a11e213"
  us-west-1:
     "32": "ami-c9c7978c"
     "64": "ami-cfc7978a"
Resources:
  myEC2Instance:
    Type: "AWS::EC2::Instance"
    Properties:
    ImageId: !FindInMap [RegionMap, !Ref "AWS::Region", 32]




Fn::ImportValue

Import values that are exported in other templates
For this, we use the Fn::ImportValue Function

     Resources:
      MyInstance:
      Type: AWS::EC2::Instances
      Properties:
        AvailabilityZone: us-east-1a
        ImageId: ami-a4c7edb 
        InstanceType: t2.micro
        SecurityGroups:
          - !ImportValue SSHSecurityGroup




Fn::Join

!Join [ delimiter, [ comma-delimited list of values]]

This creates "a:b:c"







Fn::Sub

Fn::Sub or !Sub as a shorthand is used to substitue variables from a text. Is is a very handy function that will allow you to fully customize your templates.



For example you can combine Fn::Sub with References or AWS Pseudo variables!

String must contain ${VariableName} and will substitute them

!Sub 
  - String
  - { Var1Name: Var1Value, Var2Name: Var2Value }

!Sub String 



Condition Functions




______________________________________________



CloudFormation Rollbacks

Stack Creation Fails:
  Default: everything rolls back (gets deleted) We can look at the log.
  Option to disable rollback and troubleshoot what happened.



Stack Update Fails:
  The stack automatically rolls back to the previous known working state
  Ability to see in the log what happened and error messages.




Example:

---
Parameters:
  SecurityGroupDescription:
    Description: Security Group Description
    Type: String

Resources:
  MyInstance:
    Type: AWS::EC2::Instance
    Properties:
      AvailabilityZone: us-east-1a
      ImageId: ami-123456                    -------------------> This AMI Id doesn't exist
      InstanceType: t2.micro
      SecurityGroups:
        - !Ref SSHSecurityGroup
        - !Ref ServerSecurityGroup

  # an elastic IP for our instance
  MyEIP:
    Type: AWS::EC2::EIP
    Properties:
      InstanceId: !Ref MyInstance

  # our EC2 security group
  SSHSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Enable SSH access via port 22
      SecurityGroupIngress:
      - CidrIp: 0.0.0.0/0
        FromPort: 22
        IpProtocol: tcp
        ToPort: 22

  # our second EC2 security group
  ServerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Ref SecurityGroupDescription
      SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: 80
        ToPort: 80
        CidrIp: 0.0.0.0/0
      - IpProtocol: tcp
        FromPort: 22
        ToPort: 22
        CidrIp: 192.168.1.1/32


Create a stack > Template is ready > Upload this template file


Stack failure options:
Roll back all stack resources
Preserve successfully provisioned resources. [select]


Next

It generates security groups. So you will have to delete now.





Failure on update

Create the stack based on correct template
Roll back all stack resources [select]
Preserve successfully provisioned resources.



Now select the stack > Update Stack > 

Now go with the incorrect file which will cause the failure.


This will delete if anything is created and will go back to previous state.

If you pick the other option to preserve it won't delete.





CloudFormation Drift

CloudFormation allows you to create infrastructure
But it doesn't protect you against manual configuration changes

We can use cloudformation drift!

Not all resouces are supported.
https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/detect-drift-stack.html

Parameters:
  VPCId:
    Description: VPC to create the security group into
    Type: AWS::EC2::VPC::Id
  
Resources:
  SSHSecurityGroup:
    Type: "AWS::EC2::SecurityGroup"
    Properties:
      GroupDescription: Test Drift SSH Security Group
      SecurityGroupIngress:
        - CidrIp: "10.0.0.0/25"
          FromPort: 22
          ToPort: 22
          IpProtocol: tcp
      VpcId: !Ref VPCId

  HTTPSecurityGroup:
    Type: "AWS::EC2::SecurityGroup"
    Properties:
      GroupDescription: Test Drift HTTP Security Group
      SecurityGroupIngress:
        - CidrIp: "0.0.0.0/0"
          FromPort: 80
          ToPort: 80
          IpProtocol: tcp
      VpcId: !Ref VPCId


Create stack > give name and give VpcId as it is stated as parameter in stack.


Change anything in securitygroup.



Cloud formation isn't aware yet.

Go to your stack > Stack Options > Detect Drift 


Then under stack Options > View Drift Results


Here you can see the differences between expected and actual 






CloudFormation Stack Policies

During a CloudFormation Stack update, all update actions are allowed on all resources(default)

A stack Policy is a JSON document that defines the update actions that are alowed on specific resources during stack updates.

Protect resources from unintentinal updates.

When you set a stack policy all resources in the Stack are protected by default.

Specify an explicit ALLOW for the resources you want to be allowed to be updated.





Nested Stacks

Nested stacks are stacks as part of other stacks.
They allow you to isolate repeated patterns/ common components in seprate stacks and call them from other stacks 


 Example: 
  Load Balancer configuration that is re-used
  Security group that is reused.



To update a nested stack, always update the parent(root stack)

Parameters:
  SSHKey:
    Type: AWS::EC2::KeyPair::KeyName
    Description: Name of an existing EC2 KeyPair to enable SSH access to the instance
  
Resources:
  myStack:
    Type: AWS::CloudFormation::Stack
    Properties:
      TemplateURL: https://s3.amazonaws.com/cloudformation-templates-us-east-1/LAMP_Single_Instance.template
      Parameters:
        KeyName: !Ref SSHKey
        DBName: "mydb"
        DBUser: "user"
        DBPassword: "pass"
        DBRootPassword: "passroot"
        InstanceType: t2.micro
        SSHLocation: "0.0.0.0/0"

Outputs:
  StackRef:
    Value: !Ref myStack
  OutputFromNestedStack:
    Value: !GetAtt myStack.Outputs.WebsiteURL


Create Stack > Upload file > You will have to give some permissions related to IAM.


At the time of deletion you delete the parent stack

 


ChangeSets
when you update a stackm you need to know what changes before it happens for greater confidence.
ChangeSets won't say if the update will be successful.


Orignal Stack -Create Change Set-> Change Set --View Change Set-> change set --Execute change set-> AWS CloudFormation



Create a stack: cs-demo

---
Resources:
  MyInstance:
    Type: AWS::EC2::Instance
    Properties:
      AvailabilityZone: us-east-1a
      ImageId: ami-a4c7edb2
      InstanceType: t2.micro


It will create an EC2 instance for us.


Go to change sets 

REPLACE THE CURRENT TEMPLATE WITH NEW


---
Parameters:
  SecurityGroupDescription:
    Description: Security Group Description
    Type: String

Resources:
  MyInstance:
    Type: AWS::EC2::Instance
    Properties:
      AvailabilityZone: us-east-1a
      ImageId: ami-a4c7edb2
      InstanceType: t2.micro
      SecurityGroups:
        - !Ref SSHSecurityGroup
        - !Ref ServerSecurityGroup

  # an elastic IP for our instance
  MyEIP:
    Type: AWS::EC2::EIP
    Properties:
      InstanceId: !Ref MyInstance

  # our EC2 security group
  SSHSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Enable SSH access via port 22
      SecurityGroupIngress:
      - CidrIp: 0.0.0.0/0
        FromPort: 22
        IpProtocol: tcp
        ToPort: 22

  # our second EC2 security group
  ServerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Ref SecurityGroupDescription
      SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: 80
        ToPort: 80
        CidrIp: 0.0.0.0/0
      - IpProtocol: tcp
        FromPort: 22
        ToPort: 22
        CidrIp: 192.168.1.1/32

Upload this one

Then go next, you can check changes in json or like it shows what will be the differnce.

This gives you idea of changes.

Then you can execute or delete.



Retaining Data on Deletes:

You can put a DeletionPolicy on any resource to control what happens when the CloudFormation template is deleted.

DeletionPolicy=Retain.
Specify on resources to preserve/backup in case of CloudFormation deletes 
To keep a resource, specify Retain (works for any resource/nested stack)

DeletionPolicy=Snapshot:
EBS Volume, ElasticCache Cluster, ElasticCache, ReplicationGroup
RDS DBInstance, RDS DBCluster, Redshift Cluster

DeletePolicy=Delete(default behaviour):
Note: for AWS::RDS::DBCluster resources, the default policy is Snapshot
Note: to delete an S3 bucket, you need to first empty the bucket of its content.


take this deletion-sample.yml
---
Resources:
  MySG:
    Type: AWS::EC2::SecurityGroup
    DeletionPolicy: Retain             -------------------> Retain
    Properties:
      GroupDescription: Enable SSH access via port 22
      SecurityGroupIngress:
      - CidrIp: 0.0.0.0/0
        FromPort: 22
        IpProtocol: tcp
        ToPort: 22

  MyEBS:
    Type: AWS::EC2::Volume  
    DeletionPolicy: Snapshot    --------------->Should go away but make a snapshot of it
    Properties:
      AvailabilityZone: us-east-1a
      Size: 1
      VolumeType: gp2







Create stack > upload file > once provisioned > Select the stack > Delete stack

Now check Events > You will see Security group status as deletion skipped and for EBS a snapshot created. Once snapshot is created  EBS will be deleted.






Termination Protection on Stacks:

Create a stack >  Once Created > Actions > Edit Termination Protection > Enable 
By this way you can't delete the stack without changing it to Disable







User Data in EC2 for CloudFormation

Let's learn how to write the same EC2 user-data script in our CloudFormation template

The important thing to pass is the entire script through the function Fn::Base64

Good to know, user data script log is in /var/log/cloud-init-output.log 






Let's see how to do it in cloudformation


Parameters:
  KeyName:
    Description: Name of an existing EC2 key pair for SSH access to the EC2 instance.
    Type: AWS::EC2::KeyPair::KeyName

  SSHLocation:
    Description: The IP address range that can be used to SSH to the EC2 instances
    Type: String
    MinLength: '9'
    MaxLength: '18'
    Default: 0.0.0.0/0
    AllowedPattern: "(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})/(\\d{1,2})"
    ConstraintDescription: must be a valid IP CIDR range of the form x.x.x.x/x.

  ImageId:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2

Resources:
  WebServer:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref ImageId
      InstanceType: t2.micro
      KeyName: !Ref KeyName
      SecurityGroups:
        - !Ref WebServerSecurityGroup
      UserData:
        Fn::Base64: |                               --------> Multiline string(all of the following has to be passed as Base64)
           #!/bin/bash
           yum update -y
           amazon-linux-extras install -y lamp-mariadb10.2-php7.2 php7.2
           yum install -y httpd mariadb-server
           systemctl start httpd
           systemctl enable httpd
           usermod -a -G apache ec2-user
           chown -R ec2-user:apache /var/www
           chmod 2775 /var/www
           find /var/www -type d -exec sudo chmod 2775 {} \;
           find /var/www -type f -exec sudo chmod 0664 {} \;
           echo "<?php phpinfo(); ?>" > /var/www/html/phpinfo.php

  WebServerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Enable HTTP access via port 80 + SSH access"
      SecurityGroupIngress:
      - CidrIp: 0.0.0.0/0
        FromPort: 80
        IpProtocol: tcp
        ToPort: 80
      - CidrIp: !Ref SSHLocation
        FromPort: 22
        IpProtocol: tcp
        ToPort: 22



Login to the machine created 
cat /var/log/cloud-init-output.log





It is possible that your userdata hasn't run completely on your machine but still your

events in stacks shows that it has completed the user-data.






The problem with EC2 User Data

What if we want to have a very large instance configuration?
What if we want to evolve the state of the EC2 instance without terminating it and creating a new one?
How do we make EC2 user-data more readable?
How do we know or signal that our EC2 user-data script completed successfully?


Enter CloudFormation Helper Scripts

We have 4 python scripts, that come directly on Amazon Linux 2 AMI, or can be installed using yum on non-Amazon Linux AMIs
 1. cfn-init Used to retrieve and interpret the resource metadata, installing packages, creating files and startin services.
 2. cfn-signal A simple wrapper to signal with a CreationPolicy or WaitCondition, enabling you to synchronize other resources in the stack with application being ready.
 3. cfn-get-megadata A wrapper script making it easy to retrieve either all metadata defined for a resource or path to a specific key or subtree of the resource metadata.
 4.cfn-hup A daemon to check for updates to the metadata and execute custom hooks when the changes are detected.


Usual flow: cfn-init, then cfn-signal, then optionally cfn-hup 



AWS::CloudFormation::Init



Resources:
  MyInstance:
    Type: AWS::EC2::Instance
    Metadata:
      AWS::CloudFormation::Init:
        config:
          packages:
             :
          groups:
             :
          users:
             :
          sources:
             :
          files:
             :
          commands:
             :
          services:
             :
    Properties:
      :



A config contains the following and is executed in that order:
Packages: Used to download and install pre-packages apps and components on Linux/Windows(ex. MySQL,PHP,etc...)
Groups: define user groups
Users: define users, and which group they belong to
Sources: download files and archives and place them on the EC2 instance
Files: create files on the EC2 instance,  using inline or can be pulled from a URL


You can have multiple configs in your AWS::CloudFormation::Init
You create configSets with mulitple configs
And you invoke configSets from your EC2 user-data




cfn-init 

With the cfn-init script, it helps make complex EC2 configurations readable

AWS CloudFormation launch EC2 instance
The EC2 instance will query the CloudFormation service to get init data and then runs cfn-init

Logs go to /var/log/cfn-init.log


Once we run cfn-init we still don't know how to tell CloudFormation that EC2 instance got properly configured after a cfn-init 

For this, we can use the cfn-signal script!
> We run cfn-signal right after cfn-init
> Tell CloudFormation service that the resource creation success/fail to keep on going or fail

We need to define WaitCondition:
> Block the template until it receives a signal from cfn-signal
> We attach a CreationPolicy (also works on EC2, ASG)
> We can define a Count > 1 (in case you need more than 1 signal )







AWSTemplateFormatVersion: '2010-09-09'
Description: AWS CloudFormation Sample Template for CFN Init
Parameters:
  KeyName:
    Description: Name of an existing EC2 KeyPair to enable SSH access to the instances
    Type: AWS::EC2::KeyPair::KeyName
    ConstraintDescription: must be the name of an existing EC2 KeyPair.

  SSHLocation:
    Description: The IP address range that can be used to SSH to the EC2 instances
    Type: String
    MinLength: '9'
    MaxLength: '18'
    Default: 0.0.0.0/0
    AllowedPattern: "(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})/(\\d{1,2})"
    ConstraintDescription: must be a valid IP CIDR range of the form x.x.x.x/x.

  MyS3BucketName:
    Description: Name of an existing bucket to download files from
    Type: String

  ImageId:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2

Resources:
  WebServerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Enable HTTP access via port 80 and SSH access via port 22
      SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: 80
        ToPort: 80
        CidrIp: 0.0.0.0/0
      - IpProtocol: tcp
        FromPort: 22
        ToPort: 22
        CidrIp: !Ref SSHLocation

  WebServerHost:
    Type: AWS::EC2::Instance
    Metadata:
      Comment: Install a simple PHP application
      AWS::CloudFormation::Init:
        config:
          packages:
            yum:
              httpd: []
              php: []
          groups:
            apache: {}
          users:
            "apache":
              groups:
                - "apache"
          sources:
            "/home/ec2-user/aws-cli": "https://github.com/aws/aws-cli/tarball/master"
          files:
            "/tmp/cwlogs/apacheaccess.conf":
              content: !Sub |
                [general]
                state_file= /var/awslogs/agent-state
                [/var/log/httpd/access_log]
                file = /var/log/httpd/access_log
                log_group_name = ${AWS::StackName}
                log_stream_name = {instance_id}/apache.log
                datetime_format = %d/%b/%Y:%H:%M:%S
              mode: '000400'
              owner: apache
              group: apache
            "/var/www/html/index.php":
              content: !Sub |
                <?php
                echo '<h1>AWS CloudFormation sample PHP application for ${AWS::StackName}</h1>';
                ?>
              mode: '000644'
              owner: apache
              group: apache
            "/etc/cfn/cfn-hup.conf":
              content: !Sub |
                [main]
                stack=${AWS::StackId}
                region=${AWS::Region}
              mode: "000400"
              owner: "root"
              group: "root"
            "/etc/cfn/hooks.d/cfn-auto-reloader.conf":
              content: !Sub |
                [cfn-auto-reloader-hook]
                triggers=post.update
                path=Resources.WebServerHost.Metadata.AWS::CloudFormation::Init
                action=/opt/aws/bin/cfn-init -v --stack ${AWS::StackName} --resource WebServerHost --region ${AWS::Region}
              mode: "000400"
              owner: "root"
              group: "root"
            # Fetch a webpage from a private S3 bucket
            "/var/www/html/webpage.html":
              source: !Sub "https://${MyS3BucketName}.s3.${AWS::Region}.amazonaws.com/webpage.html"
              mode: '000644'
              owner: apache
              group: apache
              authentication: S3AccessCreds
          commands:
            test:
              command: "echo \"$MAGIC\" > test.txt"
              env:
                MAGIC: "I come from the environment!"
              cwd: "~"
          services:
            sysvinit:
              httpd:
                enabled: 'true'
                ensureRunning: 'true'
              postfix:
                enabled: 'false'
                ensureRunning: 'false'
              cfn-hup:
                enable: 'true'
                ensureRunning: 'true'
                files:
                  - "/etc/cfn/cfn-hup.conf"
                  - "/etc/cfn/hooks.d/cfn-auto-reloader.conf"         "focus here too"
      AWS::CloudFormation::Authentication:
        # Define S3 access credentials
        S3AccessCreds:
          type: S3
          buckets:
            - !Sub ${MyS3BucketName}
          roleName: !Ref InstanceRole
    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
        
    Properties:
      ImageId: !Ref ImageId
      KeyName: !Ref KeyName
      InstanceType: t2.micro
      IamInstanceProfile: !Ref InstanceProfile # Reference Instance Profile
      SecurityGroups:
      - !Ref WebServerSecurityGroup
      UserData:
        Fn::Base64:
          !Sub |
            #!/bin/bash -xe
            
            # Get the latest CloudFormation helper scripts
            yum install -y aws-cfn-bootstrap
            
            # Start cfn-init                                     ----------------------> !!!!!!!Focus here!!!!!!!!!!
            /opt/aws/bin/cfn-init -v --stack ${AWS::StackName} --resource WebServerHost --region ${AWS::Region}
            
            # cfn-init completed so signal success or not
            /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource WebServerHost --region ${AWS::Region}
          

  InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: 'sts:AssumeRole'
            Principal:
              Service: ec2.amazonaws.com
            Effect: Allow
            Sid: ''
      Policies:
        - PolicyName: AuthenticatedS3GetObjects
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Action:
                  - 's3:GetObject'
                Resource: !Sub 'arn:aws:s3:::${MyS3BucketName}/*'
                Effect: Allow

  InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
        - !Ref InstanceRole

Outputs:
  InstanceId:
    Description: The instance ID of the web server
    Value:
      !Ref WebServerHost
  WebsiteURL:
    Value:
      !Sub 'http://${WebServerHost.PublicDnsName}'
    Description: URL for newly created LAMP stack
  PublicIP:
    Description: Public IP address of the web server
    Value:
      !GetAtt WebServerHost.PublicIp




1st you write down all you need in AWS::CloudFormation::Init block
then with cfn-init looks for all the metadata 
We have also attached creation policy which makes it wait for 15 mins. count by default is 1 if not given.




cfn-hup

Can e used to tell your EC2 instance to look for Metadata changes every 15 minutes and apply the Metadata configuration again.

It is very powerful but you really need to try it out to understand how it works. 
It relies on a cfn-hup configuration, see /etc/cfn/cfn-hup.conf and /etc/cfn/hooks.d/cfn-auto-reloader.conf

Cloudformation launches ec2 > ec2 instance retrieve init data from config > Signal > cdn-hup checks the metadata every 15 mins > If a change is detected in config in cloudformation > cfn-init runs again.
